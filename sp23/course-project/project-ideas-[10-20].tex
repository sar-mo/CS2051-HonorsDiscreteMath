\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumitem}

% colored links
\usepackage{hyperref} 
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    }

%Formatting and Spacing
\setitemize[1]{noitemsep, parsep = 5pt, topsep = 5pt}
\setenumerate[1]{label = (\alph*), parsep = 1pt, topsep = 5pt}
\setlength\parindent{0pt}
\linespread{1.1}

% title
\title{\vspace{-1cm}CS 2051: Honors Discrete Mathematics \\Spring 2023 Project Ideas 10-20}
\author{}
\date{}

\begin{document}

\maketitle

\subsection*{Cryptography in the Modern Age}
    Cryptography plays a vital role in ensuring secure communication in the modern age. In this project, we will be focusing on modern encryption algorithms, specifically Advanced Encryption Standard (AES). AES is a symmetric-key encryption algorithm that is widely used in various applications such as internet security protocols, electronic funds transfers, and secure communications.
    
    \vspace{3mm}
    The implementation of an encryption system using AES will be one of the main deliverables in this project. In addition to the implementation, we will delve into the mathematical foundations of AES and other encryption algorithms. This will include an in-depth analysis of the underlying mathematical concepts such as number theory, linear algebra, and cryptography-specific concepts like trapdoor functions.
    
    \vspace{3mm}
    A trapdoor function is a mathematical function that is easy to compute in one direction but difficult to compute in the opposite direction without knowing some additional information, called the trapdoor. AES makes use of this concept through the use of S-boxes, which are non-linear functions that are used to scramble the data before it is encrypted. The mathematical properties of these functions and their implementation in AES will be explored in this project.
    
    \vspace{3mm}
    Moreover, we will also delve into the mathematical concepts that AES is based on, including finite fields and Galois fields. Finite fields are mathematical structures that are similar to the field of real numbers, but they have a finite number of elements. Galois fields, also known as Galois fields, are a specific type of finite field that have important properties that make them ideal for use in cryptography. The properties and applications of finite fields and Galois fields in cryptography will be covered in this project.
    
    \vspace{3mm}
    In conclusion, this project will explore the mathematical foundations of modern cryptography, with a specific focus on AES encryption. The project will provide a comprehensive understanding of the mathematical concepts that are the building blocks of AES and other encryption algorithms, including number theory, linear algebra, finite fields, Galois fields, and trapdoor functions. The project's main deliverable will be the implementation of an AES encryption system, which will provide hands-on experience in the application of the mathematical concepts covered in this project.

\pagebreak

\subsection*{Recursive Algorithms and Fractals}
    A \textit{fractal} is a self-similar geometric shape that can be divided into smaller copies of itself. One way to generate fractals is through the use of recursive algorithms.
    
    \vspace{3mm}
    One famous example of a fractal is the \textit{Koch snowflake}, which is created by starting with an equilateral triangle, and then dividing each line segment into three equal parts, and replacing the middle part with two line segments that form a smaller equilateral triangle. This process is repeated an infinite number of times, creating a fractal shape with an infinitely complex boundary.
    
    \vspace{3mm}
    Another example of a fractal is the \textit{Mandelbrot set}, which is a set of complex numbers that exhibit complex, self-similar patterns when plotted on a graph. The algorithm for generating the Mandelbrot set is also recursive, and involves iterating the function $f_{c}(z) = z^{2} + c$ for each value of $c$ in the complex plane. The boundary of the Mandelbrot set is a fractal shape.
    
    \vspace{3mm}
    The mathematics involved in fractals and recursive algorithms includes complex numbers, iterative algorithms, and infinite sequences. In the course, we will study these mathematical concepts in more depth and apply them to the study of fractals.
    
    \vspace{3mm}
    A couple of possible areas for extension or generalizations are as follows:
    \begin{itemize}
    \item Study different types of fractals and the algorithms used to generate them, including the \textit{Sierpinski triangle}, \textit{dragon curve}, and \textit{Julia sets}.
    \item Explore the properties of fractals, including their dimensionality and self-similarity, and how these properties relate to the underlying mathematical concepts.
    \item Study applications of fractals and recursive algorithms in areas such as computer graphics, data compression, and chaos theory.
    \end{itemize}

\pagebreak

\subsection*{The Master Theorem}
    The Master Theorem is a result in the theory of algorithms that provides a framework for analyzing the running time of divide-and-conquer algorithms. Given a divide-and-conquer algorithm that solves a problem of size $n$ by dividing the problem into subproblems of size $n/b$, then solving each subproblem in $O(n^d)$ time, and then combining the solutions of the subproblems in $O(n^c)$ time, the running time of the algorithm is given by the following:
        
    $$[T(n) = O(n^d)\text{ if }d > c]$$
    $$[T(n) = O(n^c \log n)\text{ if }d = c]$$
    $$[T(n) = O(n^c)\text{ if }d < c]$$
    
    The Master Theorem is a powerful tool that simplifies the analysis of divide-and-conquer algorithms, but it has some limitations, and there are many variants of the theorem that are needed to handle specific cases.
    
    \vspace{3mm}
    In the course, we will cover the standard version of the Master Theorem and its most common variants, including the case when the running time of the divide step is $O(n^{\log_b a})$, and the case when the subproblems are not of equal size.
    
    \vspace{3mm}
    A couple of possible areas for extension or generalization are as follows:
    \begin{itemize}
    \item Consider the case when the problem is divided into more than two subproblems, or when the number of subproblems depends on the size of the problem. Analyze the running time of algorithms that divide a problem into multiple subproblems and prove an extended version of the Master Theorem.
    \item Consider the case when the running time of the algorithm depends on additional parameters, such as the size of the input or the solution, or the number of subproblems. Analyze algorithms that involve additional parameters and generalize the Master Theorem to handle these cases.
    \item Consider the case when the subproblems are not solved in a divide-and-conquer manner, but are solved using other techniques, such as dynamic programming or greedy algorithms. Analyze algorithms that involve multiple problem-solving techniques and extend the Master Theorem to handle these cases.
    \end{itemize}

\pagebreak 

\subsection*{Lambda Calculus}

Lambda calculus is a mathematical formalism that is used to describe and study computation and algorithms. It was first introduced by Alonzo Church in the 1930s, and has since become an important area of research in theoretical computer science, programming languages, and logic.

\vspace{3mm}
In lambda calculus, functions are treated as first-class citizens and can be passed as arguments to other functions, assigned to variables, and manipulated in other ways. The basic building block of lambda calculus is the \textit{lambda expression}, which is used to define anonymous functions. A lambda expression has the form $$\lambda x.\ M$$ where $x$ is the argument of the function and $M$ is the expression representing the function's body.

\vspace{3mm}
The evaluation of a lambda expression is performed by substituting the argument $x$ in $M$ with a specific value and reducing the expression until it can no longer be simplified. This process is called \textit{beta reduction}. The rules of beta reduction are well-defined and allow for the calculation of the value of a lambda expression.

\vspace{3mm}
Here are a few examples of lambda expressions:

\begin{itemize}
\item $\lambda x.\ x$ is the identity function, which simply returns its argument.
\item $\lambda x.\ x + 1$ is a function that adds 1 to its argument.
\item $\lambda x.\ \lambda y.\ x + y$ is a function that takes two arguments and returns their sum.
\end{itemize}

\vspace{3mm}
Lambda calculus has many interesting properties and features, including the ability to represent any computable function, the capability to encode simple data structures and algorithms, and the property of Turing completeness, which means that it is capable of simulating any algorithm that can be implemented on a Turing machine.

\vspace{3mm}
The aim of this project is to study the theory of lambda calculus, including its syntax, semantics, and reduction rules, as well as its applications in programming languages and computer science. In addition, students will implement a simple interpreter for lambda calculus in order to gain a deeper understanding of the subject.

\vspace{3mm}
Possible areas for extension or generalizations are as follows:
\begin{itemize}
\item Consider the theory of combinatory logic, which is a close relative of lambda calculus. Combinatory logic is characterized by the absence of variables, and as such, all functions are anonymous. The goal of this extension would be to study the theory of combinatory logic and to compare it with lambda calculus.
\item Study the theory of type systems and type inference in the context of lambda calculus. This would include an introduction to Hindley-Milner type systems, the study of type inference algorithms, and the relationship between type systems and the ability to reason about the behavior of programs.
\item Consider the use of lambda calculus in functional programming languages, such as Haskell, Scheme, and ML. Study the theory and practice of functional programming, and implement simple programs in one or more functional programming languages.
\end{itemize}

\pagebreak 

\subsection*{Godel's Incompleteness Theorem}

Godel's Incompleteness Theorem is one of the most famous results in the foundations of mathematics. It was proved by Kurt GÃ¶del in the early 20th century and states that, within any sufficiently powerful mathematical system, there will always exist statements that are true, but unprovable within the system.

\vspace{3mm}
To understand the theorem, we first need to understand the idea of Godel numbering. Given a mathematical system, we can assign a unique integer (referred to as a "Godel number") to each mathematical statement, symbol, or proof. This allows us to encode mathematical statements as integers, and perform operations on them using arithmetic. For example, the statement "2 + 2 = 4" can be encoded as the integer 123456. The statement "For all x, the statement 'x + x = 2x' is true" can also be encoded as an integer, say 654321.

\vspace{3mm}
Once we have assigned Godel numbers to our mathematical statements, we can use these numbers to reason about the statements themselves. For example, we can define the statement "$A$ implies $B$" as the statement "$\neg A \vee B$", where $\neg$ represents negation and $\vee$ represents disjunction. This means that if $A$ is the statement "$x + x = 2x$" and $B$ is the statement "$x = x$", then the statement "$A$ implies $B$" is equivalent to the statement "$\neg(x + x = 2x) \vee (x = x)$". We can then encode this statement as a Godel number, say 7890.

\vspace{3mm}
In this project, you'll use computer software to encode propositional statements as Godel numbers, as well as explore and explain Godel's first and second incompleteness theorems.

\pagebreak 

\subsection*{Combinatorial Games}
A combinatorial game is a two-player game with perfect information, where the players make moves in turn, with the aim of being the last player to make a move. In this course, we will focus on two particular games: Sprouts, and Dots and Boxes.

\vspace{3mm}
\textit{Sprouts}: Sprouts is a game played on a sheet of paper, with a pen. The game starts with a dot on the paper, and players take turns adding a new dot and connecting it to one of the existing dots by a line. The line cannot cross over any other lines. The game ends when a player is unable to add a new dot. The player who adds the last dot is the winner.

\vspace{3mm}
\textit{Dots and Boxes}: Dots and Boxes is played on a square grid of dots. The players take turns connecting two adjacent dots by a line. If a player completes a box, they write their symbol inside the box and take another turn. The game ends when all boxes have been completed. The player with the most boxes is the winner.

\vspace{3mm}
To study these games, we will use the theory of impartial combinatorial games, which assigns a mathematical value to each game, known as the nim-value or Grundy number. This allows us to determine who has a winning strategy and who does not, and also to combine games to form more complex games.

\vspace{3mm}
\textbf{Sprague-Grundy Theorem.}
Let $G_1, G_2, \dots, G_n$ be combinatorial games. The game $G = \bigoplus_{i=1}^n G_i$ is defined to be the game where players can make moves in any of the games $G_1, G_2, \dots, G_n$ in any order they choose, but once a player is unable to move in a game, they cannot make any further moves in that game. Then the nim-value of the game $G$ is equal to the nim-value of the game $G_1 \oplus G_2 \oplus \dots \oplus G_n$.

\vspace{3mm}
A couple of possible areas for extension or generalizations are as follows:
\begin{itemize}
\item Consider the game of NIM, where the players take turns removing stones from a heap. Investigate the relationship between the size of the heap and the nim-value of the game.
\item Generalize the Sprague-Grundy theorem to $m$-player games, where $m \ge 2$ players take turns making moves. Investigate how to calculate the nim-value of such games, and the conditions under which a player has a winning strategy.
\item Consider games where the moves are not deterministic. Investigate how to extend the Sprague-Grundy theorem to these games, and the conditions under which a player has a winning strategy.
\end{itemize}

\pagebreak
\subsection*{Creating Your Own Math-Based Game}
In this project, you will design, create, and analyze a math-based game. The game must be complex enough to provide a challenge to players, and must involve a significant mathematical component, such as strategy and problem-solving.

\vspace{3mm}
There are many different types of math-based games to choose from, including strategy games like chess, puzzle games like Sudoku, and combinatorial games like Conway's Game of Life (don't choose this one though!). When selecting a game to create, consider the following questions:

\begin{itemize}
\item What mathematical concepts are involved in the game?
\item What is the objective of the game?
\item How is the game played? What are the rules and how do they impact strategy?
\item What are some examples of similar games and what makes your game unique?
\end{itemize}

\vspace{3mm}
Once you have selected a game to create, you will need to carefully design and implement it. This will involve creating rules, designing a board or playing field, creating pieces or tokens, and possibly even coding a computer version of the game.

\vspace{3mm}
After you have created the game, you will need to analyze it. This will involve studying the various strategies and tactics that players can use, as well as analyzing the mathematical aspects of the game. You may also want to play the game yourself or have others play it to see how it works in practice.

\vspace{3mm}
The final step of the project will be to write a report on your game. This should include the following elements:

\begin{itemize}
\item An introduction to the game and its mathematical foundations
\item A description of the rules and how the game is played
\item An analysis of the game's mathematical properties, such as strategies, tactics, and any relevant theorems or equations
\item An explanation of any coding or programming that was involved in creating the game
\item A discussion of any challenges or limitations encountered during the creation process
\item Conclusion and future directions for the game.
\end{itemize}

\vspace{3mm}
Good luck and have fun creating your math-based game!


\pagebreak 


\subsection*{Monte Carlo Methods}
Monte Carlo methods are a family of computational algorithms that rely on repeated random sampling to compute numerical results. They are widely used in fields such as physics, finance, and engineering, among others, where mathematical models are too complex to solve analytically.


\vspace{3mm}
The basic idea behind Monte Carlo methods is to generate random samples from a given distribution, and then use these samples to estimate the desired quantity. For example, in physics, Monte Carlo methods can be used to compute the properties of complex systems, such as molecules or materials, by generating random configurations and computing the properties of interest for each one.

\vspace{3mm}
In this project, we will focus on a specific type of Monte Carlo method: Markov Chain Monte Carlo (MCMC). MCMC methods are a class of algorithms that generate random samples from a target distribution by constructing a Markov Chain that has the target distribution as its stationary distribution. The samples generated by the MCMC method are then used to estimate the desired quantity.

\vspace{3mm}
The main theorem in this area is the Metropolis-Hastings algorithm, which provides a general framework for constructing MCMC methods. The Metropolis-Hastings algorithm works as follows:
\begin{itemize}
    \item Choose an arbitrary starting state.
    \item At each step, generate a proposal state from the current state using a proposal distribution.
    \item Compute the acceptance probability of the proposal state, based on the target distribution and the proposal distribution.
    \item With probability equal to the acceptance probability, accept the proposal state as the next state. Otherwise, reject the proposal state and stay in the current state.
    \item Repeat the above steps to generate a sequence of states, which form a Markov Chain.
\end{itemize}
The Metropolis-Hastings algorithm can be seen as a generalization of the Metropolis algorithm, which is a special case of the Metropolis-Hastings algorithm where the proposal distribution is symmetric.

\vspace{3mm}
A couple of possible areas for extension or generalizations are as follows:
\begin{itemize}
    \item Consider different types of proposal distributions, such as Gaussian distributions or random walks, and compare their performance in terms of convergence to the target distribution and computational efficiency.
    \item Consider the use of parallel and distributed computing techniques to speed up the computation. For example, consider using GPU programming or cloud computing to run large-scale Monte Carlo simulations.
    \item Consider the use of adaptive MCMC methods, which dynamically update the proposal distribution based on the history of the Markov Chain, in order to improve the convergence and efficiency of the simulation.
\end{itemize}

\end{document}